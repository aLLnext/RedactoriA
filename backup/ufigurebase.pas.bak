unit UFigureBase;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils,Graphics,UFigure,Dialogs, ExtCtrls, UScale, Controls, Spin, StdCtrls, Buttons,
  UParams, LCLType, FPCanvas, TypInfo, LCL, LCLIntf, Math,
  FileUtil, Forms,fpjson, superobject,Clipbrd,
  Menus
  ;
type
  Trans = record
    transporate:boolean;
    index:integer;
    trFigure:TFigure;
  end;

  PNode = ^Node; { указатель на узел }
     Node = record
       data: TFigure;  { данные }
       next: PNode; { указатель на след. элемент }
     end;


  TTool = class
  public

    MaxPoint, MinPoint:TDoublePoint;
    FigureClass:TFigureClass;
    Names,Pic:string;
    ParPanel:TPanel;
    Poligon: TDoubleRect;
    PSize: TDoublePoint;
    WTop, WBottom: TDoublePoint;
    delta: integer;
    rBtnPressed:boolean;
    Transp:Trans;
    writePL: boolean;
    ADoublePoint:TDoublePoint;
    LastScrollBarHor, LastScrollBarVert: integer;
    procedure Scrolling(
      pb:TPaintBox;ScrollBarHor: TScrollBar; ScrollBarVert: TScrollBar);

    procedure ClearSelect;
    procedure MouseDown(APoint:TPoint);virtual;
    procedure MouseMove(APoint:TPoint);virtual;
    procedure MouseUp(APoint:TPoint);virtual;abstract;

    procedure PPanelCreate(APanel:TPanel);virtual;
    procedure MinMaxPoints;

    procedure FiguresDraw(pb:TPaintBox);
end;


  THandTool = class(TTool)
    FirstP:TPoint;
    procedure MouseDown(APoint:TPoint);override;
    procedure MouseMove(APoint:TPoint);override;
    procedure MouseUp(APoint:TPoint);override;
    procedure PPanelCreate(APanel:TPanel);override;
  end;

  TMagnifierTool = class(TTool)
    FirstP:TPoint;
    procedure MouseDown(APoint:TPoint);override;
    procedure MouseMove(APoint:TPoint);override;
    procedure MouseUp(APoint:TPoint);override;
    procedure PPanelCreate(APanel:TPanel);override;
  end;

  TPolyLineTool = class(TTool)
    procedure MouseDown(APoint:TPoint);override;
    procedure MouseMove(APoint:TPoint);override;
    procedure MouseUp(APoint:TPoint);override;
    procedure PPanelCreate(APanel:TPanel);override;
  end;

  TLineTool = class(TTool)
    procedure MouseDown(APoint:TPoint);override;
    procedure MouseMove(APoint:TPoint);override;
    procedure MouseUp(APoint:TPoint);override;
    procedure PPanelCreate(APanel:TPanel);override;
  end;

  TPenTool = class(TTool)
    procedure MouseDown(APoint:TPoint);override;
    procedure MouseMove(APoint:TPoint);override;
    procedure MouseUp(APoint:TPoint);override;
    procedure PPanelCreate(APanel:TPanel);override;
  end;

  TRectangleTool = class(TTool)
    procedure MouseDown(APoint:TPoint);override;
    procedure MouseMove(APoint:TPoint);override;
    procedure MouseUp(APoint:TPoint);override;
    procedure PPanelCreate(APanel:TPanel);override;
  end;

  TRoundRectTool = class(TTool)
    procedure MouseDown(APoint:TPoint);override;
    procedure MouseMove(APoint:TPoint);override;
    procedure MouseUp(APoint:TPoint);override;
    procedure PPanelCreate(APanel:TPanel);override;
  end;

  TEllipseTool = class(TTool)
    procedure MouseDown(APoint:TPoint);override;
    procedure MouseMove(APoint:TPoint);override;
    procedure MouseUp(APoint:TPoint);override;
    procedure PPanelCreate(APanel:TPanel);override;
  end;

  TSelectTool = class(TTool)
    FirstP:TPoint;
    iFigure:TFigure;
    GPColor:TColor;
    GPStyle:TPenStyle;
    GPWidth:integer;
    GRoundedX:integer;
    GRoundedY:integer;
    GBColor:TColor;
    GBStyle:TBrushStyle;
    bigselected:boolean;
    lineselected:boolean;
    ADPoints:Array of TDoublePoint;
    procedure MouseDown(APoint:TPoint);override;
    procedure MouseMove(APoint:TPoint);override;
    procedure MouseUp(APoint:TPoint);override;
    procedure PPanelCreate(APanel:TPanel);override;
  end;


    function isEmpty( S: PNode ): Boolean;
    function Pop ( var Head: PNode ): TFigure;
    procedure DeleteSt(var Head:PNode);
    procedure CreateStack(var Head: PNode);
    procedure Push( var Head: PNode; x: TFigure);
    procedure CleanREDOFigures;
    procedure CopyFigure;
    procedure PasteFigure;
    procedure WriteUNDOFigures;
    procedure WriteREDOFigures;
    procedure LayerDown;
    procedure LayerUp;
    function SaveFile:string;
    function SaveFigure(iFigure:TFigure):String;
    procedure LoadFile(S:string);
    procedure LoadFigure(S:String);
const
  FiguresName: Array[0..4] of TFigureClass = (TRectangle,TLine,TPenLine,TRoundRect,TEllipse);
var
  Tools: array of TTool;
  AParam: TParam;
  UndoStack:PNode;
  RedoStack:PNode;

implementation

procedure CopyFigure;
var
  iFigure:TFigure;
  s:string;
begin
  for iFigure in Figures do begin
    if iFigure.Selected then
      begin
        Clipboard.AsText:=SaveFigure(iFigure);
      end;
  end;
  ShowMessage(Clipboard.AsText);
end;

procedure PasteFigure;
begin
  if Clipboard<>nil then
    begin
      LoadFigure(Clipboard.AsText);
    end;
end;

function isEmpty ( S: PNode ): Boolean;
begin
  Result := (S = nil);
end;


function Pop ( var Head: PNode ): TFigure;
var q: PNode;
begin
  if Head = nil then begin { стек пуст }
    Result := nil; { неиспользуемый символ }
    Exit;
  end;
  Result := Head^.data;
  q := Head;
  Head := Head^.next;
  Dispose(q);
end;

procedure DeleteSt(var Head:PNode);
var q: Pnode;
begin
  if Head <> nil then begin
    q:=Head;
    Head:=Head^.next;
    Dispose(q);
  end;
end;

procedure Push( var Head: PNode; x: TFigure);
 var NewNode: PNode;
 begin
   New(NewNode);          { выделить память }
   NewNode^.data := x;    { записать символ }
   NewNode^.next := Head; { сделать первым узлом }
   Head := NewNode;
 end;

procedure CreateStack(var Head:Pnode);
begin
  Head:=nil;
end;

procedure CleanREDOFigures;
begin
  SetLength(REDOFigures,0);
end;

procedure writeUNDOFigures;
var
  i:integer;
  iFigure:TFigure;
  S:string;
begin
  if length(Figures)>0 then begin
    for iFigure in Figures do
    begin
      Push(UndoStack,iFigure);
    end;
    Push(RedoStack,UndoStack^.data);
    DeleteSt(UndoStack);
    if Length(Figures) > 0 then begin
      SetLength(Figures,High(Figures));
    end;
  end;
end;

procedure WriteREDOFigures;
var
  i:integer;
begin
  if not isEmpty(RedoStack)then begin
    Push(UndoStack,RedoStack^.data);
    SetLength(Figures,Length(Figures)+1);
    Figures[High(Figures)]:=RedoStack^.data;
    DeleteSt(RedoStack);
  end;
end;

procedure LoadFigure(S:String);
var
 JS,JS1: ISuperObject;
 JSA,JSA1:TSuperArray;
 k,i,j:integer;
 S1:string;
begin
    JS:=SO(S);
    SetLength(Figures,Length(Figures)+1);
    S1:= JS.S['name'];
    for j:=0 to Length(FiguresName)-1 do begin
      if FiguresName[j].ClassName=S1 then
        Figures[High(Figures)]:=FiguresName[j].Create;
    end;
    //JS1:=SO(JSA.S[i]);
    with Figures[High(Figures)] do begin
      PWidth:=JS.i['PenWidth'];

      PStyleInd:=JS.i['PenStyleInd'];
      PStyle:=TypePenStyle.Style[PStyleInd];
      PColor:=JS.i['PenColor'];
      BColor:=JS.i['BrushColor'];
      BStyleInd:=JS.i['BrushStyleInd'];
      BStyle:=TypeBrushStyle.Style[BStyleInd];
      RoundedX:=JS.i['RoundedX'];
      RoundedY:=JS.i['RoundedY'];
      JSA1:=JS.A['coord'];
      k:=0;
      for j:=0 to (JSA1.Length div 2)-1 do begin
        SetLength(DPoints, Length(DPoints)+1);
        DPoints[high(DPoints)]:=DoublePoint(JSA1.d[k],JSA1.d[k+1]);
        K:=k+2;
        ShowMessage(FloatToStr(DPoints[high(DPoints)].x)+' '+FloatToStr(DPoints[high(DPoints)].y));
     end;

    end;
end;


procedure LoadFile(S:string);
var
 JS,JS1: ISuperObject;
 JSA,JSA1:TSuperArray;
 load:TextFile;
 S1,buf:String;
 i,j,k:integer;
begin
  SetLength(Figures,0);
  FreeAndNil(Figures);
  JSA:=(JS.A['TFigures']);
  JS:=SO(S);
  for i:=0 to JSA.Length-1 do begin
    SetLength(Figures,Length(Figures)+1);
    S1:= SO(JSA.S[i]).S['name'];
    for j:=0 to Length(FiguresName)-1 do begin
      if FiguresName[j].ClassName=S1 then
        Figures[i]:=FiguresName[j].Create;
    end;
    JS1:=SO(JSA.S[i]);
    Figures[i].PWidth:=JS1.i['PenWidth'];
    Figures[i].PStyleInd:=JS1.i['PenStyleInd'];
    Figures[i].PStyle:=TypePenStyle.Style[Figures[i].PStyleInd];
    Figures[i].PColor:=JS1.i['PenColor'];
    Figures[i].BColor:=JS1.i['BrushColor'];
    Figures[i].BStyleInd:=JS1.i['BrushStyleInd'];
    Figures[i].BStyle:=TypeBrushStyle.Style[Figures[i].BStyleInd];
    Figures[i].RoundedX:=JS1.i['RoundedX'];
    Figures[i].RoundedY:=JS1.i['RoundedY'];
    JSA1:=SO(JSA.S[i]).A['coord'];
    k:=0;
    for j:=0 to (JSA1.Length div 2)-1 do begin
      SetLength(Figures[i].DPoints, Length(Figures[i].DPoints)+1);
      Figures[i].DPoints[high(Figures[i].DPoints)]:=DoublePoint(JSA1.d[k],JSA1.d[k+1]);
      K:=k+2;
    end;
  end;
end;

function SaveFigure(iFigure:TFigure):String;
var
   jObject, jFigure: TJSONObject;
   j:integer;
begin
   with iFigure do begin
   jFigure := TJSONObject.Create;
   jFigure.Add('name', ClassName);
   jFigure.Add('coord',TJSONArray.Create);
   for j := 0 to high(Dpoints) do begin
     jFigure.Arrays['coord'].Add(Dpoints[j].x);
     jFigure.Arrays['coord'].Add(Dpoints[j].y);
   end;
   jFigure.Add('PenColor', PColor);
   jFigure.Add('PenStyleInd',  PStyleInd);
   jFigure.Add('PenWidth',PWidth);
   jFigure.Add('BrushColor', BColor);
   jFigure.Add('BrushStyleInd', BStyleInd);
   jFigure.Add('RoundedX',RoundedX);
   jFigure.Add('RoundedY',RoundedY);
   end;
   //jObject.Arrays['TFigures'].Add(jFigure);
 Result:=jFigure.FormatJSON;
end;

function SaveFile:String;
var
  i, j:integer;
  jObject, jFigure: TJSONObject;
  S:string;
begin
  jObject := TJSONObject.Create;
  jObject.Add('RedactoriA@',1);
  jObject.Add('TFigures', TJSONArray.Create);
  for i:= 0 to High(Figures) do
  begin
    jFigure := TJSONObject.Create;
    jFigure.Add('name', Figures[i].ClassName);
    jFigure.Add('coord',TJSONArray.Create);
    for j := 0 to high(Figures[i].Dpoints) do begin
      jFigure.Arrays['coord'].Add(Figures[i].Dpoints[j].x);
      jFigure.Arrays['coord'].Add(Figures[i].Dpoints[j].y);
    end;
    jFigure.Add('PenColor', Figures[i].PColor);
    jFigure.Add('PenStyleInd',  Figures[i].PStyleInd);
    jFigure.Add('PenWidth',Figures[i].PWidth);
    jFigure.Add('BrushColor', Figures[i].BColor);
    jFigure.Add('BrushStyleInd', Figures[i].BStyleInd);
    jFigure.Add('RoundedX',Figures[i].RoundedX);
    jFigure.Add('RoundedY',Figures[i].RoundedY);
    jObject.Arrays['TFigures'].Add(jFigure);
  end;
  Result:=jObject.FormatJSON;
end;

procedure TTool.MouseDown(Apoint:TPoint);
begin
  ADoublePoint:=Canvas2Wrld(APoint);
  SetLength(Figures[High(Figures)].DPoints, length(Figures[High(Figures)].DPoints)+1);
  Figures[High(Figures)].DPoints[High( Figures[High(Figures)].DPoints)]:=ADoublePoint;
  SetLength(Figures[High(Figures)].DPoints, length(Figures[High(Figures)].DPoints)+1);
  Figures[High(Figures)].DPoints[High( Figures[High(Figures)].DPoints)]:=ADoublePoint;
end;

procedure TTool.MouseMove(Apoint:TPoint);
begin
  ADoublePoint:=Canvas2Wrld(APoint);
  Figures[High(Figures)].DPoints[High(Figures[High(Figures)].DPoints)]:=ADoublePoint;
end;

procedure TTool.ClearSelect;
var
  iFigure:TFigure;
begin
  for iFigure in Figures do
    if iFigure.Selected then
      iFigure.Selected:=false;
end;

procedure TTool.PPanelCreate(APanel:TPanel);
begin
  AParam.CreateSpinEdit(APanel, 'Pen Width', PenWidthInt, @AParam.PenWidthChange);
  AParam.CreateComboBox(APanel, 'Pen Style', TypePenStyle.Name, PenStyle.Index, @AParam.PenStyleChange);
  AParam.CreateColorButton(APanel, 'Pen Color', PenColor, @AParam.PenColorButtonChanged);
end;

procedure TTool.Scrolling(pb:TPaintBox;ScrollBarHor: TScrollBar;
    ScrollBarVert: TScrollBar);
begin
  Poligon :=DoubleRect(MinPoint, MaxPoint);
 WTop := Canvas2Wrld(Point(0,0));
  if Poligon.Top.X > WTop.x then
     Poligon.Top.x := WTop.x;
  if Poligon.Top.y > WTop.y then
     Poligon.Top.y := WTop.y;
  WBottom := Canvas2Wrld(Point(pb.Width, pb.Height));
  if Poligon.Bottom.x < WBottom.x then
     Poligon.Bottom.x := WBottom.x;
  if Poligon.Bottom.y < WBottom.y then
     Poligon.Bottom.y := WBottom.y;
  PSize.X := Poligon.Bottom.x - Poligon.Top.x;
  PSize.Y := Poligon.Bottom.y - Poligon.Top.y;
  if PSize.x * PSize.y = 0 then exit;

  delta := ScrollBarHor.Max - ScrollBarHor.Min;
  ScrollBarHor.PageSize := round(pb.Width / (PSize.X * Zoom) * delta);
  ScrollBarHor.Visible := ScrollBarHor.PageSize < delta;
  if ScrollBarHor.PageSize < delta then
  begin
    if (LastScrollBarHor = ScrollBarHor.Position) then
      ScrollBarHor.Position := round(((-1) * (offset.x + Poligon.Top.x)) / PSize.X * delta)
    else
      offset.x := (-1) * round(ScrollBarHor.Position / delta * PSize.x + Poligon.Top.x);
    LastScrollBarHor := ScrollBarHor.Position;
  end;

  delta := ScrollBarVert.Max - ScrollBarVert.Min;
  ScrollBarVert.PageSize := round(pb.Height / (PSize.y * Zoom) * delta);
  ScrollBarVert.Visible := ScrollBarVert.PageSize < delta;
  if ScrollBarVert.PageSize < delta then
  begin
    if (LastScrollBarVert = ScrollBarVert.Position) then
      ScrollBarVert.Position := round(((-1) * (offset.y + Poligon.Top.y)) / PSize.Y * delta)
    else
      offset.y := (-1) * round(ScrollBarVert.Position / delta * PSize.y + Poligon.Top.y);
    LastScrollBarVert := ScrollBarVert.Position;
  end;
end;

procedure TTool.MinMaxPoints;
var
  i:TFigure;
begin
  if Length(Figures)>0 then begin
  MaxPoint.x:=Figures[0].maxPoint.x;
  MinPoint.x:=Figures[0].minPoint.x;
  MaxPoint.y:=Figures[0].maxPoint.y;
  MinPoint.y:=Figures[0].minPoint.y;
  end;
  for i in Figures do begin
    if(i.maxPoint.x > MaxPoint.x) then
      MaxPoint.x:=i.maxPoint.x;
    if(i.minPoint.x < MinPoint.x) then
      MinPoint.x:=i.minPoint.x;
    if(i.maxPoint.y > MaxPoint.y) then
      MaxPoint.y:=i.maxPoint.y;
    if(i.minPoint.y < MinPoint.y) then
      MinPoint.y:=i.minPoint.y;
  end;
end;

procedure THandTool.MouseDown(APoint:TPoint);
begin
  FirstP:=APoint;
end;

procedure THandTool.MouseMove(APoint:TPoint);
begin
  Offset.x += round((APoint.x - FirstP.x)/Zoom);
  Offset.y += round((APoint.y - FirstP.y)/Zoom);
  FirstP:=APoint;
end;

procedure THandTool.MouseUp(APoint:TPoint);
begin

end;

procedure THandTool.PPanelCreate(APanel: TPanel);
begin

end;

procedure TLineTool.MouseDown(APoint:TPoint);
begin
  SetLength(Figures, Length(Figures) + 1);
  Figures[High(Figures)] := TLine.Create;
  inherited;
end;

procedure TLineTool.MouseMove(APoint:TPoint);
begin
  inherited;
end;

procedure TLineTool.MouseUp(APoint:TPoint);
begin

end;

procedure TLineTool.PPanelCreate(APanel: TPanel);
begin
  inherited;
end;

procedure TPolyLineTool.MouseDown(APoint:TPoint);
begin
  SetLength(Figures, Length(Figures) + 1);
  Figures[High(Figures)] := TPenLine.Create;
  inherited;
  writePL:=true;
end;

procedure TPolyLineTool.MouseMove(APoint:TPoint);
begin
  SetLength(Figures[High(Figures)].DPoints, length(Figures[High(Figures)].DPoints)+1);
  inherited;
end;

procedure TPolyLineTool.MouseUp(APoint:TPoint);
begin

end;

procedure TPolyLineTool.PPanelCreate(APanel: TPanel);
begin
  inherited;
end;

procedure TPenTool.MouseDown(APoint:TPoint);
begin
  SetLength(Figures, Length(Figures) + 1);
  Figures[High(Figures)] := TPenLine.Create;
  inherited;
end;

procedure TPenTool.MouseMove(APoint:TPoint);
begin
  SetLength(Figures[High(Figures)].DPoints, length(Figures[High(Figures)].DPoints)+1);
  inherited;
end;

procedure TPenTool.MouseUp(APoint:TPoint);
begin

end;

procedure TPenTool.PPanelCreate(APanel:TPanel);
begin
  inherited;
end;

procedure TRectangleTool.MouseDown(APoint:TPoint);
begin
  SetLength(Figures, Length(Figures) + 1);
  Figures[High(Figures)] := TRectangle.Create;
  inherited;
end;

procedure TRectangleTool.MouseMove(APoint:TPoint);
begin
  inherited;
end;

procedure TRectangleTool.MouseUp(APoint:TPoint);
begin

end;

procedure TRectangleTool.PPanelCreate (APanel: TPanel);
begin
  AParam.CreateColorButton(APanel, 'Brush Color', BrushColor, @AParam.BrushColorButtonChanged);
  AParam.CreateComboBox(APanel, 'Brush Style', TypeBrushStyle.Name, BrushStyle.Index, @AParam.BrushStyleChange);
  inherited;
end;

procedure TEllipseTool.MouseDown(APoint:TPoint);
begin
  SetLength(Figures, Length(Figures) + 1);
  Figures[High(Figures)] := TEllipse.Create;
  inherited;
end;

procedure TEllipseTool.MouseMove(APoint:TPoint);
begin
  inherited;
end;

procedure TEllipseTool.MouseUp(APoint:TPoint);
begin

end;

procedure TEllipseTool.PPanelCreate(APanel: TPanel);
begin
  AParam.CreateColorButton(APanel, 'Brush Color', BrushColor, @AParam.BrushColorButtonChanged);
  AParam.CreateComboBox(APanel, 'Brush Style', TypeBrushStyle.Name, BrushStyle.Index, @AParam.BrushStyleChange);
  inherited;
end;

procedure TRoundRectTool.MouseDown(APoint:TPoint);
begin
  SetLength(Figures, Length(Figures) + 1);
  Figures[High(Figures)] := TRoundRect.Create;
  inherited;
end;

procedure TRoundRectTool.MouseMove(APoint:TPoint);
begin
  inherited;
end;

procedure TRoundRectTool.MouseUp(APoint:TPoint);
begin

end;

procedure TRoundRectTool.PPanelCreate(APanel: TPanel);
begin
  AParam.CreateColorButton(APanel, 'Brush Color', BrushColor, @AParam.BrushColorButtonChanged);
  AParam.CreateComboBox(APanel, 'Brush Style', TypeBrushStyle.Name, BrushStyle.Index, @AParam.BrushStyleChange);
  AParam.CreateSpinEdit(APanel, 'Round Y', RoundY, @AParam.RoundYChange);
  AParam.CreateSpinEdit(APanel, 'Round X', RoundX, @AParam.RoundXChange);
  inherited;
end;

procedure TSelectTool.MouseDown(APoint:TPoint);
const
  k=5;
var
  i:integer;
  TL,BR:TPoint;
begin
  if not rBtnPressed then begin
    SetLength(Figures, Length(Figures) + 1);
    Figures[High(Figures)] := TSelect.Create;
    inherited;
    ADPoints:=Figures[High(Figures)].DPoints;
  end
  else if rBtnPressed  then begin
    FirstP:=APoint;
     for iFigure in Figures do begin
       if iFigure.Selected then
         for i:=0 to Length(iFigure.DPoints)do begin
           TL:=Point(Wrld2Canvas(iFigure.DPoints[i]).x-k-iFigure.PWidth div 2,Wrld2Canvas(iFigure.DPoints[i]).y-k-iFigure.PWidth div 2);
           BR:=Point(Wrld2Canvas(iFigure.DPoints[i]).x+k+iFigure.PWidth div 2,Wrld2Canvas(iFigure.DPoints[i]).y+k+iFigure.PWidth div 2);
           if iFigure.CheckRectangle(TL,BR,APoint) then begin
             Transp.transporate:=true;
             Transp.index:=i;
             Transp.trFigure:=iFigure;
          end;
       end;
    end;
  end;
end;

procedure TSelectTool.MouseMove(APoint:TPoint);
var
  i:integer;
begin
  if not rBtnPressed then begin
    ADPoints[high(ADPoints)]:=ADoublePoint;
    inherited;
  end
  else if not Transp.transporate then begin
    for iFigure in Figures do begin
    if iFigure.Selected then begin
      if (iFigure.CheckRectangle(Wrld2Canvas(iFigure.LTop),Wrld2Canvas(iFigure.RBottom),FirstP)) then begin
      for i:=0 to Length(iFigure.DPoints)-1 do begin
         iFigure.DPoints[i].x += round((APoint.x - FirstP.x)/Zoom);
         iFigure.DPoints[i].y += round((APoint.y - FirstP.y)/Zoom);
       end;
       FirstP:=APoint;
       end;
      end;
    end;
  end
  else begin
  for iFigure in Figures do begin
    if iFigure.Selected then begin
      Transp.trFigure.DPoints[Transp.index].x += ((APoint.x - FirstP.x)/Zoom);
      Transp.trFigure.DPoints[Transp.index].y += ((APoint.y - FirstP.y)/Zoom);
      FirstP:=APoint;
    end;
   end;
  end;
end;

procedure TSelectTool.MouseUp(APoint:TPoint);
begin
  if (Length(ADPoints)) = 2 then
    if (abs(ADPoints[0].x - ADPoints[1].x) < 2) and
       (abs(ADPoints[0].y - ADPoints[1].y) < 2) then
      SetLength(ADPoints, length(ADPoints) - 1);

  if (length(ADPoints) = 1) then begin
    for iFigure in Figures do begin
      iFigure.CheckPtIn(Wrld2Canvas(ADPoints[0]));
    end;
    SetLength(ADPoints, length(ADPoints)- 1);
  end;

  if (length(ADPoints) = 2) then begin
    for iFigure in Figures do
      iFigure.CheckRect(Wrld2Canvas(ADPoints[0]), Wrld2Canvas(ADPoints[1]));
    SetLength(ADPoints, length(ADPoints) - 2);
    end;

 if (Length(Figures)<>0) and (Figures[High(Figures)].ClassName = 'TSelect') then
    SetLength(Figures, length(Figures) - 1);
  if rBtnPressed then begin
    rBtnPressed:=false;
    Transp.transporate:=false;
  end;


end;

procedure TSelectTool.PPanelCreate(APanel: TPanel);
begin
   bigselected:=false;
   lineselected:=false;
    for iFigure in Figures do begin
      if (iFigure.Selected) then begin
          GPColor:=iFigure.PColor;
          GPStyle:=iFigure.PStyle;
          GPWidth:=iFigure.PWidth;
          GRoundedX:=iFigure.RoundedX;
          GRoundedY:=iFigure.RoundedY;
          GBColor:=iFigure.BColor;
          GBStyle:=iFigure.BStyle;
          BrushStyle.Index:=iFigure.BStyleInd;
          PenStyle.Index:=iFigure.PStyleInd;
        if iFigure.ClassParent = TFillFigures then
          bigselected:=true
        else
          lineselected:=true;
      end;
    end;

  if lineselected then begin
    AParam.CreateComboBox(APanel, 'Pen Style', TypePenStyle.Name, PenStyle.Index, @AParam.SelectedPenStyleChange);
    AParam.CreateColorButton(APanel, 'Pen Color', GPColor, @AParam.SelectedPenColorButtonChanged);
    AParam.CreateSpinEdit(APanel, 'Pen Width', GPWidth, @AParam.SelectedPenWidthChange);
  end
  else if bigselected then begin
    if (iFigure.ClassName='TRoundRect') then begin
      AParam.CreateSpinEdit(APanel, 'Round Y', GRoundedY, @AParam.SelectedRoundYChange);
      AParam.CreateSpinEdit(APanel, 'Round X', GRoundedX, @AParam.SelectedRoundXChange);
    end;
    AParam.CreateColorButton(APanel, 'Brush Color', GBColor, @AParam.SelectedBrushColorButtonChanged);
    AParam.CreateComboBox(APanel, 'Brush Style', TypeBrushStyle.Name, BrushStyle.Index, @AParam.SelectedBrushStyleChange);
    AParam.CreateComboBox(APanel, 'Pen Style', TypePenStyle.Name, PenStyle.Index, @AParam.SelectedPenStyleChange);
    AParam.CreateColorButton(APanel, 'Pen Color', GPColor, @AParam.SelectedPenColorButtonChanged);
    AParam.CreateSpinEdit(APanel, 'Pen Width', GPWidth, @AParam.SelectedPenWidthChange);
  end;
  AParam.CreateDeleteButton(Apanel,@AParam.DeleteFigure);

end;

procedure LayerDown;
var
  i, j: integer;
  Buff: array of TFigure;
begin
  j := high(Figures);
  SetLength(Buff, 0);

  for i := high(Figures) downto 0 do
    if (Figures[i].Selected) then begin
      SetLength(Buff, length(Buff) + 1);
      Buff[high(Buff)] := Figures[i];
    end else begin
      Figures[j] := Figures[i];
      Dec(j);
    end;

  for i := 0 to j do
    Figures[i] := Buff[j - i];
  end;

procedure LayerUp;
var
  i, j: integer;
  Buff: array of TFigure;
begin
  j := 0;
  SetLength(Buff, 0);

  for i := 0 to high(Figures) do
    if (Figures[i].Selected) then begin
      SetLength(Buff, length(Buff) + 1);
      Buff[high(Buff)] := Figures[i];
    end else begin
      Figures[j] := Figures[i];
      inc(j);
    end;

  for i := j to high(Figures) do
    Figures[i] := Buff[i - j];
end;

procedure TMagnifierTool.MouseDown(APoint:TPoint);
begin
  //FirstP:=APoint;
end;

procedure TMagnifierTool.MouseMove(APoint:TPoint);
begin

end;

procedure TMagnifierTool.MouseUp(APoint:TPoint);
const
  ZoomStep=1;
begin
  {if (Button = mbLeft) then begin
    if Zoom=FloatSpinZoom.Value then
      if FloatSpinZoom.Value < ZoomStep then
        FloatSpinZoom.Value:=FloatSpinZoom.Value+(ZoomStep div 10)
      else
        FloatSpinZoom.Value:=FloatSpinZoom.Value+(ZoomStep);
    Zoom:=FloatSpinZoom.Value;
    Offset.x:=round(((Offset.x-x)*Zoom/LastZoom)+x);
    Offset.y:=round(((Offset.y-y)*Zoom/LastZoom)+y);
    LastZoom:=Zoom;
  end else if (Button = mbRight)then begin
    if Zoom=FloatSpinZoom.Value then
      if FloatSpinZoom.Value <= ZoomStep then
        FloatSpinZoom.Value:=FloatSpinZoom.Value-(ZoomStep div 10)
      else
        FloatSpinZoom.Value:=FloatSpinZoom.Value-(ZoomStep);
    Zoom:=FloatSpinZoom.Value;
    Offset.x:=round(((Offset.x-x)*Zoom/LastZoom)+x);
    Offset.y:=round(((Offset.y-y)*Zoom/LastZoom)+y);
    LastZoom:=Zoom;
  end;  }
end;

procedure TMagnifierTool.PPanelCreate(APanel: TPanel);
begin

end;

procedure TTool.FiguresDraw(pb:TPaintBox);
var
  i:integer;
  AFigure:TFigure;
begin
  for i:=0 to High(Figures) do begin
    AFigure:=Figures[i];
      AFigure.Draw(pb.Canvas);
  end;
end;

procedure RegisterTool(Tool: TTool; AFigureClass: TFigureClass;AName:String;APicName:String);
begin
  SetLength(Tools, Length(Tools) + 1);
  Tools[High(Tools)] := Tool;
  Tools[High(Tools)].FigureClass := AFigureClass;
  Tools[High(Tools)].Names:=AName;
  Tools[High(Tools)].Pic:=APicName;
end;

procedure RegisterBrushSt(AStyle: TBrushStyle; AName: string);
begin
  SetLength(TypeBrushStyle.Name, Length(TypeBrushStyle.Name)+1);
  SetLength(TypeBrushStyle.Style, Length(TypeBrushStyle.Style)+1);
  TypeBrushStyle.Name[High(TypeBrushStyle.Name)]:=AName;
  TypeBrushStyle.Style[High(TypeBrushStyle.Style)]:=AStyle;
end;

procedure RegisterPenSt(AStyle: TPenStyle; AName: string);
begin
  SetLength(TypePenStyle.Name, Length(TypePenStyle.Name)+1);
  SetLength(TypePenStyle.Style, Length(TypePenStyle.Style)+1);
  TypePenStyle.Name[High(TypePenStyle.Name)]:=AName;
  TypePenStyle.Style[High(TypePenStyle.Style)]:=AStyle;
end;

initialization
  RegisterTool(TLineTool.Create, TLine,'Line','assets/line.bmp');
  RegisterTool(TRectangleTool.Create, TRectangle,'Rectangle','assets/rectangle.bmp');
  RegisterTool(TEllipseTool.Create, TEllipse,'Ellipse','assets/ellipse.bmp');
  RegisterTool(TPolylineTool.Create, TLine,'Polyline','assets/lines.bmp');
  RegisterTool(THandTool.Create, nil ,'Hand', 'assets/hand.bmp');
  RegisterTool(TPenTool.Create, TPenLine,'Pen', 'assets/pencil.bmp');
  RegisterTool(TRoundRectTool.Create, TRoundRect,'RoundRect','assets/roundrect.bmp');
  //RegisterTool(TMagnifierTool.Create, nil ,'Magnifier','assets/pencil.bmp');
  RegisterTool(TSelectTool.Create, nil ,'Select','assets/select.bmp');

  RegisterBrushSt(bsBDiagonal, 'BDiagonal');
  RegisterBrushSt(bsFDiagonal, 'FDiagonal');
  RegisterBrushSt(bsCross, 'Cross');
  RegisterBrushSt(bsDiagCross, 'Diag Cross');
  RegisterBrushSt(bsHorizontal, 'Horizontal');
  RegisterBrushSt(bsVertical, 'Vertical');
  RegisterBrushSt(bsSolid, 'Solid');

  RegisterPenSt(psDash, 'Dash');
  RegisterPenSt(psDashDot, 'Dash-Dot');
  RegisterPenSt(psDashDotDot, 'Dash-Dot-Dot');
  RegisterPenSt(psDot, 'Dot');
  RegisterPenSt(psInsideframe, 'Inside Frame');
  RegisterPenSt(psSolid, 'Solid');
end.

